---
title: "数电入门"
date: 2024-11-27
---

# Number and Code
## Numerical Systems
- **radix** decimal(d/10), binary(b/2), octal(o/8), hexadecimal(h/16)
- **conversion** (Integral parts) repeated division-by-2/8/16, (Fractions part) repeated multiplication by 2/8/16
- **signed number** 
  |sign-magnitude|1's complement(反码)|2's complement(补码)|
  |---|---|---|
  |$\pm 0$|$-2^{n-1}+1\sim 2^{n-1}-1, \pm 0$|$-2^{n-1}\sim 2^{n-1}-1$|
  |0 101|0101|0101|
  |1 101|1010|1011|

- **arithmetic operations** addition&subtraction (overflow!), multiplication (direct addition, partial products)
- **floating-point numbers** 
  single-precision = sign bit (1S) + exponential (8E) + mantissa (23F) = $\pm$(1+.F)$\times2^{E-127}$

## Coding
- BCD, 8421, excess-3 cycle, <span style="color:red">gray code</span>
- parity error detection code (P=0 when even/odd 1s)
- <span style="color:red">hamming code</span> $2^P\ge P+D+1$ e.g. $P_1P_2D_1P_3D_2D_3D_4$, $P_1=(1,3,5,7), P_2=(2,3,6,7), P_3=(4,5,6,7)$
# Combinational Logic
## Basics
- **logic gates**
  NOT, AND, OR, NAND/negative-OR($\overline{AB}=\bar{A}+\bar{B}$), NOR/negative-AND($\overline{A+B}=\bar{A}\bar{B}$), XOR($A\bar{B}+\bar{A}B$), XNOR($AB+\bar{A}\bar{B}$)
- **simplication, standard forms**
![](./SOP_POS.png)

## Applications
- **adder**
  - **half-adder** $C_\text{out}=AB, \Sigma=A\oplus B$, no input carry bit
  - **full-adder** $C_\text{out}=AB+(A\oplus B)C_\text{in}, \Sigma=(A\oplus B)\oplus C_\text{in}$
  - **parallel binary adder** 
  - **ripple carry adder** cascading
  - **look-ahead carry adder** an output carry bit can be either generated by inputs $C_g=AB$, or propagated by input carry $C_p=A+B$, $C_\text{out}=C_g+C_pC_\text{in}$
- **comparator**
  - **1-bit** $$\begin{aligned}&Y_{1}(A<B)=\overline{A}B\\&Y_{2}(A=B)=\overline{A\oplus B}\\&Y_{3}(A>B)=A\overline{B}\end{aligned}$$
  - **higher bit?** cascading LSB->MSB->result
- **decoder&encoder** expansion of bits by cascading chips and enabling one at the same time
- **multiplexer&demultiplexer**

## Race and Hazard
Race: time delay between parallel signals
Hazard: race causing incorrect transient output
Hazard in $C+\bar{C}, C\bar{C}$ happens when switching from a variable to its complement (time delay).
$Y=A\bar{C}+\bar{A}B+\bar{A}C$, both $A$ and $C$ have race; e.g. when $B=1,C=0$, $A$ arises hazard. Tangent circles in the K-map arises hazard.

> How to avoid static hazard?
> 1. modify logic design, add redundant terms $Y=B\bar{C}+AC\rightarrow Y=B\bar{C}+AC+AB$ (eliminate tangent circles)
> 2. enable signal
> 3. filtering


# Sequential Logic
## Latches and Flip-flops
> - all logics for S-R latch are reversed when using NAND (negative-OR)
> - pay special attention to negative inputs: gated S-R latch inverts inputs so that they're still active-high
> - inverting bubbles can move along a line and cancel each other
> - 对于negative input,可以$\overline{\text{input}}=\text{input\_new}$,直接化为对应的negative output
> - 可以通过工作时段判断类型: posedge-triggered FF对应slave在反时钟的low/posedge工作, 即为NOR型, 反之则为NAND型; master相反

![](./latch.svg)

## What is sequential logic?
实际上是将时序逻辑按状态机考虑,分离为迭代过程($Q^n\rightarrow Q^{n+1}$)与组合逻辑(f(状态,输入/控制变量), 表达式, 列表与k-map是不同的表示方式). 复杂问题建议用K-map, 输入为自变量, 输出为所求因变量.<!-- 例如求drive equation: 将k-map的自变量改为Qs, 因变量改为S/R, 忽略x态 -->

Find $S,R$ or $D$ or $J,K$ for the logic relationship to organize it in form of the drive equation

Conversion between FFs: $\text{drive variable}=f(Q(\text{combination logic}))=g(\text{drive variable'})$
可以出现反馈回路形式的输入, 只要组合逻辑关系符合即可

||JK|T|D|
|---|---|---|---|
|JK|$J=Q^{n+1},K=\bar{Q^{n+1}}$|$J=K=T$|$J=D,K=\bar{D}$|
|T|$T=J\bar{Q^n}+KQ^n$|$T=Q^n\oplus Q^{n+1}$|$T=D\oplus Q^n$|
|D|$D=J\bar{Q^n}+\bar{K}Q^n$|$D=T\oplus Q^n$|$D=Q^{n+1}$|


<!-- T'FF=TFF when T==1 -->
## Propagation Delay

## Applications



- **data storage (parallel)**
- **frequency division** 偶数次分频, 广义的counter
- **register (serial)** 
    - DFF in series, synchronous triggered $(Q_0Q_1Q_2Q_3)^{n+1}=(S_{in}Q_0Q_1Q_2)^n$
    

- **counter** $M$ modulus = number of effective states
    - frequency dividing asynchronous counter ($2^{n-1}<M\le 2^n$, TFF)
        $CP_{i+1}=Q_i, T=1$ and $R=S=0$ / transition state $R=\text{modulus}, S=\text{modulus}-1$
        > 看起来反手反脚的方法有望避免glitch        
            
    - frequency dividing synchronous counter
        $CP_{i+1}=CLK, T_i=f(Q_0,\dots,Q_{i-1})$ 更低位全为0/1时翻转
        
    - up/down counter (see 10-45)
    - register shift counter (DFF) 只变首尾,逐级传输
        - Johnson Counter (M=2N) $D_0=\bar{Q_{n-1}}$ 各级FF占空比恒定
        - Ring Counter (M=N) $D_0=Q_{n-1}$ FF输出个数恒定
    - common counter + decoder
      generate pulse as register shift ones (m序列)
# Integrated Chips
考试的时候会给,不用背
- adder
- comparator
- register
    - <span style="color:red">74LS194</span>
      
    |$S_1S_0$|operation|
    |---|---|
    |00|keep|
    |01|right shift, $D_{SR}$ in|
    |10|left shift, $D_{SL}$ in|
    |11|parallel data $ABCD$ in|

- counter
  把transition state 的$\sum{Q_i}$连到clear(R)或load(S); 引脚特性决定syn./asyn.
  通过因子分解,以反馈设置对应R/S触发条件,级联多个芯片,可以实现更丰富的modulus
    - asynchronous decade counter <span style="color:red">74LS290</span> (JK FF)

      |pin|meaning|operation|
      |---|---|---|
      |$\bar{A},Q_A$|clk and output for $M=2$||
      |$\bar{B}, \left\{Q_DQ_CQ_B\right\}$|clk and outputs for $M=5$||

      可以用来实现编码: 1. BCD(8421) 5\*2; 2. 5421 2\*5
      低位信号有时候不一定需要复位信号
      <!-- async复位的时刻受"时钟"周期约束, 而不是瞬间发生, 因而可能省略部分reset和set信号 -->
      注意异步需要多一个!
    - synchronous counter <span style="color:red">74LS163</span> (syn. clr)

      |pin|meaning|operation|
      |---|---|---|
      |$DCBA$|||
      |$\overline{CLR}, \overline{LD}$|clear, load|priorty|
      |$P$|parallel load enable|$PT=11$ enable|
      |$T$|toggle enable|$PT=01/x0$ keep|
      |$RCO$|ripple carry output (end mark)||

      先级联后反馈: 1--P1--P2, 1--T1, RCO1--T2, LD--1/RCO2
      先反馈后级联: 1--P1--T1, P2--T2--CLR1/LD1
    - synchronous counter <span style="color:red">74LS161</span> (asyn. clr)
  
# Sequential Logic Analysis
analysis steps: 
1. combinational: Write down the **drive equation** of each FF and the output
2. sequential: Substitute the drive equation into each **state equation** and find out the state transition relationship $Q^{n+1}=f(X,Q^n)$

design steps:
1. define, simplify and assign states
   - simplify: eliminate equivalant states with same output and equivalent next state (隐含表法列举等价条件逐步排除); 注意mealy是X/Z, 而moore是Q/Z
   - assign and encode: state = combinations of outputs (from flip-flop output) $A_{2^{FF}}^k$, $2^{FF}\ge \text{output bits}$; adjacent assignment method (same next state>last state>output)
   - now we have a state transition diagram $Q^{n+1},Z=f(X,Q^n)$
2. get expressions of FF drive variables $g(X,Q^n)$ from $Q^{n+1,n}$ using
   - directly substituting drive equation
   - mechanically listing truth table
   - k-map, just flip x and y; 或者从状态图的k-map中直接挑出每个状态对应的形式,不起效的部分填上x
   - 自启动,就是保证所有x取的次态都接到主环上
3. 对于寄存器式counter状态迁移必须满足移位条件(只变首尾,单向传输),把所有状态连到一个环上
   
# Integrated Circuits
## Diode
## MOSFET
- 互补逻辑门(对偶网络) for NMOS, series=AND, parallel=OR
- output impedance varies ($0.5r_o, r_o, 2r_o$)$\rightarrow$ 输入端越多$V_{OL},V_{OH}$整体偏高/低; 缓冲级(inverter)解决上述问题
- OD门,线与(并联的CS?)
- 三态门: EN=0, Y=Z; EN=1, 反相
## BJT
- 输入级(并联->AND)+倒相级+输出级(推挽式)
- OC门,线与(并联的CE?)
